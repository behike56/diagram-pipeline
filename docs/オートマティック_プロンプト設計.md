# オートマティック_プロンプト設計.md

## 3. API + スクリプトで自動化するときのパイプライン

最終的にやりたいのはおそらくこちらだと思うので、簡単な構成案も書いておきます。

### 3-1. 全体フロー

1. **リポジトリを取得**

   * CI（GitHub Actions / GitLab CI など）で `git checkout`
2. **対象ファイルを抽出**

   * `**/*.(tf|yaml|yml|json)` / `k8s/` / `infra/` / `src/` ディレクトリなど
3. **チャンク化**

   * 1ファイルを数百行ごとのチャンクに分ける
4. **構造抽出 API 呼び出し**

   * 2章の「構造抽出プロンプト」を system / user に組み込み、JSON を取得
   * すべてのチャンクの JSON をローカルでマージ
5. **PlantUML 生成 API 呼び出し**

   * マージした JSON を渡して「全体図」「サブシステム別の図」など複数種類の PlantUML を生成
6. **ファイルとして保存**

   * 例: `diagrams/infrastructure.puml`, `diagrams/k8s.puml`, `diagrams/class-diagram.puml` など
7. **PlantUML レンダリング（オプション）**

   * CI 上で SVG/PNG 出力 → アーティファクト or gh-pages へ公開

### 3-2. 実装時の工夫ポイント

* **JSON スキーマを決めておく**

  * `resources` / `objects` / `classes` / `components` / `relations` などの共通スキーマに寄せると後の処理が楽です
* **図ごとに別のプロンプトに分ける**

  * 1つのプロンプトで「インフラ図もクラス図もシーケンス図も」は混乱しやすいので、

    * `infra_json → infra.puml`
    * `k8s_json → k8s.puml`
    * `code_json → class_diagram.puml`
    * `usecase_description → sequence_diagram.puml`
* **差分生成にも対応**

  * 将来的には「前回の JSON」と「今回の JSON」を比較して変化の大きいところだけ再生成、なども可能

---
