# マニュアル_プロンプト設計.md

## 1. 全体アーキテクチャイメージ

ざっくり分けると、どの入力でも流れは同じです。

1. **対象ファイルを抽出する**

   * 例: `template.yml` / `main.tf` / `deployment.yaml` / 主要なソースコード
2. **構造をテキスト・JSONで整理させる**

   * 「どんなリソース・コンポーネントがあるか」「どう依存しているか」を ChatGPT に抽出させる
3. **構造情報 → PlantUML に変換させる**

   * 「コンポーネント図」「デプロイメント図」「クラス図」「シーケンス図」など
4. **PlantUML をレンダリングする**

   * PlantUML Server や PlantUML CLI で PNG/SVG 生成（これは ChatGPT の外の処理）

ChatGPT にやらせるのは ②③ の部分です。

---

## 2. ChatGPT で手動実行するときのプロンプト設計

### 2-1. 入力ファイルの渡し方

1画面で収まるサイズに**小さく分割して渡す**のが基本です。

* CloudFormation / Terraform / K8s:

  * リソースの定義がまとまっている単位でチャンク
  * 例: VPCまわり、ECSまわり、RDSまわり… など
* ソースコード:

  * 1クラス or 1モジュール単位でチャンク
  * もしくは「パッケージ構成の一覧 → 代表的なクラス」

### 2-2. ステップ1：構造抽出用プロンプト

#### (A) CloudFormation → 構造抽出

````text
以下の AWS CloudFormation テンプレートから、システム構成の要素と関係を抽出してください。

出力は JSON 形式で、次のようにしてください。

- resources: リソースの一覧
  - id: 論理ID
  - type: AWS:: から始まるリソースタイプ
  - role: VPC / Subnet / ALB / EC2 / RDS / S3 / IAM Role など、人間にわかりやすい区分
- relations: リソース間の関係
  - source: 論理ID
  - target: 論理ID
  - kind: attached-to / in-subnet / uses / depends-on などの簡潔な関係種別
  - detail: 参照しているプロパティ名などの補足

テンプレート:

```yaml
(ここに CloudFormation テンプレート)
```

````

#### (B) Terraform → 構造抽出

````text
以下の Terraform コードから、インフラ構成の要素と関係を抽出してください。

出力は JSON 形式で、次のようにしてください。

- resources:
  - id: resource "<type>" "<name>" の "<type>.<name>"
  - type: aws_vpc / aws_subnet / aws_lb / aws_instance など
  - role: VPC / Subnet / ALB / EC2 / RDS / S3 / IAM Role など、人間にわかりやすい区分
- relations:
  - source: "<type>.<name>"
  - target: "<type>.<name>"
  - kind: attached-to / in-subnet / uses / depends-on
  - detail: 参照している属性名などの補足

コード:

```hcl
(ここに Terraform コード)
```

````

#### (C) Kubernetes マニフェスト → 構造抽出

````text
以下の Kubernetes マニフェストから、アプリケーション構成の要素と関係を抽出してください。

出力は JSON 形式で、次のようにしてください。

- objects:
  - name: メタデータ名
  - kind: Deployment / Service / Ingress / ConfigMap / Secret / Namespace など
  - role: API / Backend / DB / Cache など、人間にわかりやすい区分（推測でOK）
- relations:
  - source: オブジェクト名
  - target: オブジェクト名
  - kind: exposes / routes-to / mounts / uses-config など
  - detail: port 番号や path などの補足

マニフェスト:

```yaml
(ここに K8s マニフェスト)
```
````

#### (D) アプリケーションソースコード → クラス / コンポーネント構造抽出

````text
以下のソースコードから、クラス・モジュール構造を抽出してください。

出力は JSON 形式で、次のようにしてください。

- classes:
  - name
  - package (言語に応じて適切に)
  - methods: 代表的なメソッド名の配列
  - depends_on: このクラスが直接利用しているクラス名の配列
- components:
  - name: コンポーネント名（Controller / Service / Repository など大きめの単位）
  - kind: controller / service / repository / external-api / database など
  - classes: 含まれるクラス名の配列
- relations:
  - source_component
  - target_component
  - kind: calls / queries / publishes / subscribes など

ソースコード:

```(ここにソースコード)```
````

---

### 2-3. ステップ2：構造情報 → PlantUML 生成プロンプト

構造 JSON が取れたら、それを入力として PlantUML を作らせます。

#### (1) インフラ系（CloudFormation / Terraform / K8s）→ コンポーネント図

````text
次の JSON は、インフラ/アプリケーション構成の要素と関係を表しています。
この JSON をもとに、PlantUML のコンポーネント図を生成してください。

条件:
- 出力は ```plantuml 〜 ``` のコードブロックのみ
- @startuml から @enduml までを含める
- AWS リソースや K8s オブジェクトごとに stereotype を付与する
  - 例: [WebApp] <<EC2>>、[DB] <<RDS>>、[api-service] <<Deployment>>
- relations.kind に応じて、矢印の種類・ラベルを工夫する
  - uses: -->、in-subnet: -down-、attached-to: ..> など

構造 JSON:

```json
(ここにさっき ChatGPT に作らせた JSON)
```
````

#### (2) クラス図用 PlantUML

````text
次の JSON はクラス構造を表しています。
これをもとに、PlantUML のクラス図を生成してください。

条件:
- 出力は ```plantuml 〜 ``` のコードブロックのみ
- 主要なクラスのフィールド・メソッド名を数個ずつ含める（すべては不要）
- depends_on をクラス間の関連として矢印で表現する

JSON:

```json
(クラス構造の JSON)
```
````

#### (3) シーケンス図用 PlantUML

ソースコードや仕様書からユースケースを抽象化して書かせます。

````text
以下の説明とコード片から、「ユーザーが〇〇を実行する」ユースケースの処理シーケンスを抽象化してください。
その上で、PlantUML のシーケンス図を生成してください。

条件:
- 出力は ```plantuml 〜 ``` のコードブロックのみ
- ライフラインは 5〜10 個程度にまとめる（Controller / Service / Repository / 外部API / DB など）
- 細かい内部処理よりもコンポーネント間のやり取りを重視する

(仕様やコードの説明をここにペースト)
````

### 2-4. PlantUML 出力の品質を安定させるポイント

* **「PlantUML だけを出力して」** と強く指定
  → 解説文が混ざると CI などで扱いにくい
* **コードブロック指定**（ ```plantuml ）で囲ませる
* 大きくなりすぎる場合は「図を複数に分けてよい」と指示する
